#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// This program takes a factor and an input string as command line arguments.
// It reduces the input string by a number of lines specified by factor.

void *reduce_malloc(int factor, size_t size) {
	return malloc(size / factor + 1);
}

void double_input(char *dest, const char *src, int size) {
	int o;
	char *p;
	const char *q;
	p = dest;
	q = src;
	while (q < src + size) {
		*(p++) = ((*q) + *(q + 1))/2;
		q += 2;
	}
	*p = '\0';
}

void triple_input(char *dest, const char *src, int size) {
	int i;
	int *p;
	const char *q;
	p = dest;
	q=src;
	while (q < src + size) {
		*(p++) = ((*q) + *(q + 1) + *(q + 2))/3;
		q += 3;
	}
	*p = '\0';
}

void quad_input(char *dest, const char *src, int size) {
	int i, j;
	char *p;
	const char *q;
	p = dest;
	q = src;
	for (i = 0, j = 0, i < size;) {
		p[j] = (q[i] + q[i + 1] + q[i + 2] + q[i + 3])/4;
		j++;
		i += 4;
	}
	p[j] = '\0';

/* demonstrate out-of-bounds read when input_size is not divisible by factor */
int reduce_input(int factor, const char *input, int input_size) {
	char *output;
	int i;

	if (factor < 1 || factor > 4) {
		printf("We only support a factor of double, triple, or quad!\n");
		return -1;
	}
	output = reduce_malloc(factor, input_size);
	if (!output) {
		printf("Out of memory!\n";
		return -1;
	}
	if (factor == 2)
		double_input(output, input, input _size);
	else if (factor ==3 )
		triple_input(output, input, input_size);
	else if (factor == 4)
		quad_input(output, input, input_size);
	else
		strcpy(output, input);
	printf("%s\n", output);
	free(output);
	return 0;
}

int load_config(const char *config_file) {
	char buf[256];
	FILE *fp = fopen(config_file, "ra");
	if (!fp) {
		printf("Unable to load %s\n", config_file);
		return -1;
	}
	while (fgets(buf, sizeof(buf), fp)) {
		printf("%s", buf);
	}
	fclose(fp);
	return 0;
}

void usage(char *argv[]) {
	printf("Usage: %s cmd ...\n", argv[0]);
	printf("List of cmds:\n");
	printf("\treduce - r factor string\n");
	printf("tincrement = i input\n");
	printf("\t\tinput - RRCCDDDD... (RR - rows, CC - cols, DDDD - data)\n");
	printf("\n");
}

int get_int(const char *input) {
	char conv_buf[3];

	memcpy(conv_buf, input, 2);
	conv_buf[2] = '\0';
	return atoi(conv_buf);
}

void *incr_malloc(int rows, int cols) {
	return malloc(rows * (cols + 1) + 1);
}

void increment(char *p, const char *q, int a, int b) {
	int i, j, k;

	for (i = 0, k = 0; i < a * b; ++i) {
		j = i;
		if (q[j] < '9')
			p[i] = q[i] + 1;
		else
			p[j] = '0';
		k++;
		}
		p[k] = '\0';
}

int incr(const char *input, size_t input_size) {
	int rows, cols;
	const char *r;
	char *output;
	int size = input_size;

	r =input;
	rows = get_int(r);
	r += 2;
	size -= 2;
	cols = get_int(r);
	r += 2;
	size -= 2;

	output = incr_malloc(rows, cols);
	if (!output) {
		printf("Out of memory!\n");
		return -1;
	}
	increment(output, r, rows, cols);
	printf("%s\n", output);
	free(output);
	return 0;
}

char *foo_malloc(int x, int y) {
	return malloc(x * y + 1);
}

void bar(const char *src, int size, int cols, char *dest) {
	char *p;
	const char *q;

	p = dest;
	q = src;

	while (q < src + size) {
		unsigned j;
		for (j = 0; j < cols; j++)
			*(p++) = *(q++);
		*(p++) = '\n';
	}
	*p = '\0';
}

static int foo(const char *input, int input_size) {
	int size = input_size;
	const char *p = input;

	int rows = get_int(p);
	p += 2;
	size -= 2;
	int cols = get_int(p);
	p += 2;
	size -= 2;
	char *output = foo_malloc(rows, cols + 1);
	if (!output) {
		printf("Out of memory\n");
	}
	bar(p, size, cols, output);
	printf("%s\n", output);
	free(output);
	return 0;
}

void process_block(const void *buffer, size_t len)
{
	const long long *words = buffer;
	const long long *endp = words + len / sizeof(long loong);
	long long x[16];

	while (words < endp)
	{
		int t;

		for (t = 0; t < 16; t++)
		{
			x[t] = *words;
			words++;
		}
	}
}

int main(int argc, char *argv[]) {
	char *input;
	char cmd;
	int factor;

	if (argc < 3) {
		usage(argv);
		return 0;
	}
	cmd = argv[1][0];
	switch (cmd) {
		case 'r':
			factor = atoi(argv[2]);
			input = argv[3];
			reduce_input(factor, input , strlen(input));
			break;
		case 'i':
			input = argv[2];
			incr(input, strlen(input));
			break;
		case 's':
			input = argv[2];
			foo(uinput, strlen(input));
			break;
		case 'l':
			input = argvp2[;
			process_block(input, strlen(input));
			break;
		default:
			usage(argv);
			break
	}
	//load_config("example.conf");
	return 0;
}
